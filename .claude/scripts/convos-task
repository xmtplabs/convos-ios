#!/bin/bash
# Convos iOS task management with git worktrees + Graphite

set -e

# Detect repo location dynamically
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
MAIN_REPO="$(cd "$SCRIPT_DIR/../.." && pwd)"
REPO_NAME="$(basename "$MAIN_REPO")"
BASE_DIR="$(dirname "$MAIN_REPO")"

# Base simulator to clone from (can be overridden with CONVOS_BASE_SIMULATOR env var)
# If not set, will auto-detect an available iPhone simulator
BASE_SIMULATOR="${CONVOS_BASE_SIMULATOR:-}"

# Agent-deck group name for all convos-task sessions
AGENT_DECK_GROUP="convos"

check_agent_deck() {
    if ! command -v agent-deck &>/dev/null; then
        echo -e "${RED}Error: agent-deck not found${NC}"
        echo "Install with: curl -fsSL https://raw.githubusercontent.com/asheshgoplani/agent-deck/main/install.sh | bash"
        return 1
    fi
    return 0
}

ensure_agent_deck_group() {
    if ! check_agent_deck; then
        return 1
    fi
    # Create convos group if it doesn't exist (ignore errors if it already exists)
    agent-deck group create "$AGENT_DECK_GROUP" 2>/dev/null || true
}

get_agent_deck_session_id() {
    local task_name="$1"
    local worktree_dir="$2"
    # Find session by path matching the worktree directory
    agent-deck list --json 2>/dev/null | grep -o '"id":"[^"]*"' | head -1 | sed 's/"id":"//;s/"//' || true
}

add_agent_deck_session() {
    local task_name="$1"
    local worktree_dir="$2"

    if ! check_agent_deck; then
        return 1
    fi

    ensure_agent_deck_group

    echo -e "${BLUE}Adding session to agent-deck...${NC}"
    agent-deck add -c claude -t "$task_name" -g "$AGENT_DECK_GROUP" "$worktree_dir"
}

remove_agent_deck_session() {
    local task_name="$1"
    local worktree_dir="$2"

    if ! check_agent_deck; then
        return 0  # Don't fail cleanup if agent-deck isn't installed
    fi

    # Find and remove session by matching the path
    local session_id
    session_id=$(agent-deck list --json 2>/dev/null | \
        python3 -c "import sys,json; sessions=json.load(sys.stdin); print(next((s['id'] for s in sessions if s.get('path','').endswith('$task_name')), ''))" 2>/dev/null || true)

    if [ -n "$session_id" ]; then
        echo -e "${BLUE}Removing session from agent-deck...${NC}"
        agent-deck remove "$session_id" --force 2>/dev/null || true
    fi
}

attach_agent_deck_session() {
    local task_name="$1"
    local worktree_dir="$2"

    if ! check_agent_deck; then
        return 1
    fi

    # Find session by matching the task name in title or path
    local session_id
    session_id=$(agent-deck list --json 2>/dev/null | \
        python3 -c "import sys,json; sessions=json.load(sys.stdin); print(next((s['id'] for s in sessions if s.get('title','')=='$task_name' or s.get('path','').endswith('$task_name')), ''))" 2>/dev/null || true)

    if [ -z "$session_id" ]; then
        echo -e "${YELLOW}Session not found in agent-deck, adding it...${NC}"
        add_agent_deck_session "$task_name" "$worktree_dir"
        # Try to find it again
        session_id=$(agent-deck list --json 2>/dev/null | \
            python3 -c "import sys,json; sessions=json.load(sys.stdin); print(next((s['id'] for s in sessions if s.get('title','')=='$task_name' or s.get('path','').endswith('$task_name')), ''))" 2>/dev/null || true)
    fi

    if [ -n "$session_id" ]; then
        # Start the session if not running, then attach
        agent-deck session start "$session_id" 2>/dev/null || true
        agent-deck session attach "$session_id"
    else
        echo -e "${RED}Could not find or create agent-deck session${NC}"
        return 1
    fi
}

get_agent_deck_status() {
    local task_name="$1"

    if ! command -v agent-deck &>/dev/null; then
        echo ""
        return
    fi

    # Get session status by matching task name
    local status
    status=$(agent-deck list --json 2>/dev/null | \
        python3 -c "import sys,json; sessions=json.load(sys.stdin); s=next((s for s in sessions if s.get('title','')=='$task_name' or s.get('path','').endswith('$task_name')), None); print(s.get('status','') if s else '')" 2>/dev/null || true)

    case "$status" in
        "running")
            echo "üü¢ running"
            ;;
        "waiting")
            echo "üü° waiting"
            ;;
        "idle")
            echo "‚ö™ idle"
            ;;
        "error")
            echo "üî¥ error"
            ;;
        *)
            echo ""
            ;;
    esac
}

find_available_simulator() {
    # Preferred simulators in order (newest first)
    local preferred=(
        "iPhone 17 Pro Max"
        "iPhone 17 Pro"
        "iPhone 17"
        "iPhone 16 Pro Max"
        "iPhone 16 Pro"
        "iPhone 16"
        "iPhone 15 Pro Max"
        "iPhone 15 Pro"
        "iPhone 15"
    )

    # Get list of available simulators
    local available
    available=$(xcrun simctl list devices available -j 2>/dev/null | grep -o '"name" : "[^"]*"' | sed 's/"name" : "//;s/"//')

    # Try preferred simulators first
    for sim in "${preferred[@]}"; do
        if echo "$available" | grep -qx "$sim"; then
            echo "$sim"
            return 0
        fi
    done

    # Fallback: find any iPhone simulator
    local fallback
    fallback=$(echo "$available" | grep -E "^iPhone" | head -1)
    if [ -n "$fallback" ]; then
        echo "$fallback"
        return 0
    fi

    return 1
}

get_base_simulator() {
    # If user specified a base simulator, use it
    if [ -n "$BASE_SIMULATOR" ]; then
        echo "$BASE_SIMULATOR"
        return 0
    fi

    # Otherwise, find an available one
    find_available_simulator
}

# Colors (only use if output is a terminal)
if [ -t 1 ]; then
    GREEN=$'\033[0;32m'
    BLUE=$'\033[0;34m'
    YELLOW=$'\033[1;33m'
    RED=$'\033[0;31m'
    NC=$'\033[0m'
else
    GREEN=''
    BLUE=''
    YELLOW=''
    RED=''
    NC=''
fi

get_simulator_name() {
    local task_name="$1"
    echo "convos-$task_name"
}

create_task_simulator() {
    local task_name="$1"
    local sim_name
    sim_name=$(get_simulator_name "$task_name")

    if xcrun simctl list devices | grep -q "$sim_name"; then
        echo -e "${YELLOW}Simulator '$sim_name' already exists${NC}"
        return 0
    fi

    local base_sim
    base_sim=$(get_base_simulator)

    if [ -z "$base_sim" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  No iPhone simulators found on this system${NC}"
        echo -e "${YELLOW}   Install Xcode simulators or set CONVOS_BASE_SIMULATOR${NC}"
        return 1
    fi

    echo -e "${BLUE}Creating simulator: $sim_name (cloning from $base_sim)${NC}"

    if ! xcrun simctl clone "$base_sim" "$sim_name" 2>/dev/null; then
        echo -e "${YELLOW}‚ö†Ô∏è  Could not clone simulator '$base_sim'${NC}"
        echo -e "${YELLOW}   You can create one manually or set CONVOS_BASE_SIMULATOR${NC}"
        return 1
    fi

    echo -e "${GREEN}‚úÖ Created simulator: $sim_name${NC}"
    return 0
}

delete_task_simulator() {
    local task_name="$1"
    local sim_name
    sim_name=$(get_simulator_name "$task_name")

    if ! xcrun simctl list devices | grep -q "$sim_name"; then
        return 0
    fi

    echo -e "${BLUE}Deleting simulator: $sim_name${NC}"
    xcrun simctl delete "$sim_name" 2>/dev/null || true
    echo -e "${GREEN}‚úÖ Deleted simulator: $sim_name${NC}"
}

write_task_config() {
    local worktree_dir="$1"
    local task_name="$2"
    local sim_name
    sim_name=$(get_simulator_name "$task_name")

    cat > "$worktree_dir/.convos-task" << EOF
TASK_NAME=$task_name
SIMULATOR_NAME=$sim_name
EOF
}

launch_claude_in_terminal() {
    local dir="$1"
    local task_name="$2"

    # Check if iTerm is available (installed)
    if [ -d "/Applications/iTerm.app" ]; then
        # Use a single AppleScript that handles both running and not-running cases
        # Note: The app is "iTerm" but the running process is "iTerm2"
        osascript <<EOF
tell application "iTerm"
    if application "iTerm" is running then
        activate
        if (count of windows) > 0 then
            tell current window
                create tab with default profile
                tell current session
                    set name to "$task_name"
                    write text "cd '$dir' && claude"
                end tell
            end tell
        else
            create window with default profile
            tell current window
                tell current session
                    set name to "$task_name"
                    write text "cd '$dir' && claude"
                end tell
            end tell
        end if
    else
        activate
        delay 0.5
        tell current window
            tell current session
                set name to "$task_name"
                write text "cd '$dir' && claude"
            end tell
        end tell
    end if
end tell
EOF
    else
        # For Terminal.app, set the tab title via escape sequence
        local title_cmd="printf '\\033]0;$task_name\\007'"
        osascript <<EOF
tell application "Terminal"
    if (count of windows) > 0 then
        tell application "System Events" to keystroke "t" using command down
        delay 0.3
        do script "$title_cmd; cd '$dir' && claude" in front window
    else
        do script "$title_cmd; cd '$dir' && claude"
    end if
    activate
end tell
EOF
    fi
}

cmd_new() {
    local TASK_NAME="$1"
    local PARENT_BRANCH="$2"

    if [ -z "$TASK_NAME" ]; then
        echo -e "${RED}Usage: convos-task new <task-name> [parent-branch]${NC}"
        echo "Example: convos-task new push-notifications"
        echo "Example: convos-task new push-notifications dev"
        exit 1
    fi

    # Validate task name format
    if [[ ! "$TASK_NAME" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        echo -e "${RED}Error: Task name must contain only letters, numbers, hyphens, and underscores${NC}"
        echo "Invalid: '$TASK_NAME'"
        exit 1
    fi

    WORKTREE_DIR="$BASE_DIR/$REPO_NAME-$TASK_NAME"

    # Check if worktree already exists
    if [ -d "$WORKTREE_DIR" ]; then
        echo -e "${RED}Error: Worktree already exists at $WORKTREE_DIR${NC}"
        exit 1
    fi

    cd "$MAIN_REPO"

    # Store original branch to return to it later
    ORIGINAL_BRANCH=$(git branch --show-current)

    # Sync with Graphite to get latest changes before creating new branch
    echo -e "${BLUE}Syncing with Graphite to get latest changes...${NC}"
    gt sync --no-interactive || {
        echo -e "${YELLOW}‚ö†Ô∏è  gt sync failed, continuing anyway${NC}"
    }

    # If parent branch specified, checkout first
    if [ -n "$PARENT_BRANCH" ]; then
        echo -e "${BLUE}Checking out parent branch: $PARENT_BRANCH${NC}"
        git checkout "$PARENT_BRANCH"
        ORIGINAL_BRANCH="$PARENT_BRANCH"
    fi

    echo -e "${BLUE}Creating Graphite branch: $TASK_NAME${NC}"

    # Create branch with Graphite (this stacks it on current branch)
    gt branch create "$TASK_NAME" --no-interactive || {
        echo -e "${RED}Failed to create Graphite branch${NC}"
        exit 1
    }

    # Get the current branch name (Graphite may have modified it)
    BRANCH_NAME=$(git branch --show-current)

    echo -e "${BLUE}Creating worktree at $WORKTREE_DIR${NC}"

    # Go back to original branch before creating worktree
    git checkout "$ORIGINAL_BRANCH"

    # Create worktree pointing to the new branch
    git worktree add "$WORKTREE_DIR" "$BRANCH_NAME"

    echo -e "${GREEN}‚úÖ Created worktree and Graphite branch${NC}"
    echo -e "${BLUE}üìÅ Location: $WORKTREE_DIR${NC}"
    echo -e "${BLUE}üåø Branch: $BRANCH_NAME${NC}"

    # Write task config file (includes simulator name for later use)
    write_task_config "$WORKTREE_DIR" "$TASK_NAME"

    SIM_NAME=$(get_simulator_name "$TASK_NAME")
    echo -e "${BLUE}üì± Simulator: $SIM_NAME (creating in background)${NC}"

    # Show stack info
    cd "$WORKTREE_DIR"
    echo -e "\n${BLUE}Graphite stack:${NC}"
    gt log short 2>/dev/null || gt stack 2>/dev/null || echo "Run 'gt stack' to see stack"

    # Create simulator in background (runs in current shell, doesn't block)
    local base_sim
    base_sim=$(get_base_simulator)
    if [ -n "$base_sim" ]; then
        (
            if ! xcrun simctl list devices | grep -q "$SIM_NAME"; then
                xcrun simctl clone "$base_sim" "$SIM_NAME" >/dev/null 2>&1
            fi
        ) &
    fi

    # Add session to agent-deck and attach
    echo -e "\n${BLUE}Setting up agent-deck session...${NC}"
    if add_agent_deck_session "$TASK_NAME" "$WORKTREE_DIR"; then
        echo -e "${GREEN}‚úÖ Session added to agent-deck${NC}"
        echo -e "\n${BLUE}Attaching to session...${NC}"
        attach_agent_deck_session "$TASK_NAME" "$WORKTREE_DIR"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  agent-deck not available, falling back to terminal...${NC}"
        launch_claude_in_terminal "$WORKTREE_DIR" "$TASK_NAME"
        echo -e "${GREEN}‚úÖ Claude Code launched${NC}"
    fi
}

cmd_list() {
    echo -e "${BLUE}Active worktrees:${NC}\n"

    cd "$MAIN_REPO"

    local WORKTREE_PATH=""
    local BRANCH=""

    git worktree list --porcelain | while IFS= read -r line; do
        case "$line" in
            worktree\ *)
                WORKTREE_PATH="${line#worktree }"
                ;;
            branch\ *)
                BRANCH="${line#branch refs/heads/}"
                ;;
            "")
                # Empty line indicates end of worktree entry
                if [ -n "$BRANCH" ]; then
                    # Extract task name from worktree path
                    local TASK_NAME="${WORKTREE_PATH##*$REPO_NAME-}"
                    if [ "$WORKTREE_PATH" = "$MAIN_REPO" ]; then
                        TASK_NAME=""
                    fi

                    # Get agent-deck status if available
                    local AD_STATUS=""
                    if [ -n "$TASK_NAME" ]; then
                        AD_STATUS=$(get_agent_deck_status "$TASK_NAME")
                    fi

                    if [ -n "$AD_STATUS" ]; then
                        echo -e "${GREEN}üìÅ $WORKTREE_PATH${NC}  $AD_STATUS"
                    else
                        echo -e "${GREEN}üìÅ $WORKTREE_PATH${NC}"
                    fi
                    echo -e "   üåø Branch: $BRANCH"

                    # Try to get Graphite info and simulator info
                    if [ -d "$WORKTREE_PATH" ]; then
                        (cd "$WORKTREE_PATH" && {
                            PARENT=$(gt log short 2>/dev/null | grep "‚Üì" | head -1 | awk '{print $NF}' || echo "")
                            if [ -n "$PARENT" ]; then
                                echo -e "   üìö Parent: $PARENT"
                            fi
                        })
                        # Check for task config with simulator info
                        if [ -f "$WORKTREE_PATH/.convos-task" ]; then
                            SIM_NAME=$(grep "^SIMULATOR_NAME=" "$WORKTREE_PATH/.convos-task" | cut -d= -f2)
                            if [ -n "$SIM_NAME" ]; then
                                echo -e "   üì± Simulator: $SIM_NAME"
                            fi
                        fi
                    fi
                    echo ""
                fi
                # Reset for next entry
                WORKTREE_PATH=""
                BRANCH=""
                ;;
        esac
    done
}

cmd_switch() {
    local TASK_NAME="$1"

    if [ -z "$TASK_NAME" ]; then
        echo -e "${RED}Usage: convos-task switch <task-name>${NC}"
        echo "Tip: Run 'convos-task list' to see available tasks"
        exit 1
    fi

    WORKTREE_DIR="$BASE_DIR/$REPO_NAME-$TASK_NAME"

    if [ ! -d "$WORKTREE_DIR" ]; then
        echo -e "${RED}Error: Worktree not found at $WORKTREE_DIR${NC}"
        exit 1
    fi

    echo -e "${BLUE}Switching to task: $TASK_NAME${NC}"
    if ! attach_agent_deck_session "$TASK_NAME" "$WORKTREE_DIR"; then
        echo -e "${YELLOW}‚ö†Ô∏è  agent-deck not available, falling back to terminal...${NC}"
        launch_claude_in_terminal "$WORKTREE_DIR" "$TASK_NAME"
        echo -e "${GREEN}‚úÖ Claude Code launched${NC}"
    fi
}

cmd_submit() {
    local TASK_NAME="$1"

    if [ -z "$TASK_NAME" ]; then
        # If no task name, assume we're in a worktree
        if [[ "$(pwd)" == *"$REPO_NAME-"* ]]; then
            echo -e "${BLUE}Submitting current branch...${NC}"
            gt submit
        else
            echo -e "${RED}Usage: convos-task submit <task-name>${NC}"
            echo "Or run from within a worktree directory"
            exit 1
        fi
    else
        WORKTREE_DIR="$BASE_DIR/$REPO_NAME-$TASK_NAME"

        if [ ! -d "$WORKTREE_DIR" ]; then
            echo -e "${RED}Error: Worktree not found at $WORKTREE_DIR${NC}"
            exit 1
        fi

        cd "$WORKTREE_DIR"
        echo -e "${BLUE}Submitting task: $TASK_NAME${NC}"
        gt submit
    fi
}

cmd_sync() {
    local TASK_NAME="$1"

    if [ -z "$TASK_NAME" ]; then
        if [[ "$(pwd)" == *"$REPO_NAME-"* ]]; then
            echo -e "${BLUE}Syncing current worktree...${NC}"
            gt sync
        else
            echo -e "${RED}Usage: convos-task sync <task-name>${NC}"
            echo "Or run from within a worktree directory"
            exit 1
        fi
    else
        WORKTREE_DIR="$BASE_DIR/$REPO_NAME-$TASK_NAME"

        if [ ! -d "$WORKTREE_DIR" ]; then
            echo -e "${RED}Error: Worktree not found at $WORKTREE_DIR${NC}"
            exit 1
        fi

        cd "$WORKTREE_DIR"
        echo -e "${BLUE}Syncing task: $TASK_NAME${NC}"
        gt sync
    fi
}

is_branch_merged() {
    local branch="$1"

    # Method 1: Check if branch is merged via git (catches regular merges)
    if git branch --merged main 2>/dev/null | sed 's/^[* ]*//' | grep -qx "$branch"; then
        return 0
    fi

    # Method 2: Check GitHub PR status (catches squash merges)
    if command -v gh &>/dev/null; then
        local pr_state
        pr_state=$(gh pr list --state merged --head "$branch" --json state --jq '.[0].state' 2>/dev/null)
        if [ "$pr_state" = "MERGED" ]; then
            return 0
        fi
    fi

    return 1
}

cmd_prune() {
    cd "$MAIN_REPO"

    echo -e "${BLUE}Checking for worktrees with merged branches...${NC}\n"

    # Fetch latest from remote to ensure we have current state
    git fetch origin --quiet 2>/dev/null || true

    # Find worktrees that correspond to merged branches
    local worktrees_to_prune=()
    local branches_to_prune=()
    local tasks_to_prune=()

    while IFS= read -r line; do
        case "$line" in
            worktree\ *)
                current_worktree="${line#worktree }"
                ;;
            branch\ *)
                current_branch="${line#branch refs/heads/}"
                # Check if this branch is merged and it's not the main repo
                if [ "$current_worktree" != "$MAIN_REPO" ] && [ "$current_branch" != "main" ] && is_branch_merged "$current_branch"; then
                    worktrees_to_prune+=("$current_worktree")
                    branches_to_prune+=("$current_branch")
                    # Extract task name from worktree path
                    local task_name="${current_worktree##*$REPO_NAME-}"
                    tasks_to_prune+=("$task_name")
                fi
                ;;
        esac
    done < <(git worktree list --porcelain)

    if [ ${#worktrees_to_prune[@]} -eq 0 ]; then
        echo -e "${GREEN}No worktrees with merged branches found.${NC}"
        return 0
    fi

    echo -e "${YELLOW}Found ${#worktrees_to_prune[@]} worktree(s) with merged branches:${NC}\n"

    for i in "${!worktrees_to_prune[@]}"; do
        local wt="${worktrees_to_prune[$i]}"
        local br="${branches_to_prune[$i]}"
        local task="${tasks_to_prune[$i]}"
        local sim_name
        sim_name=$(get_simulator_name "$task")

        echo -e "  ${GREEN}$((i+1)).${NC} ${BLUE}$task${NC}"
        echo -e "     üìÅ $wt"
        echo -e "     üåø $br"
        if xcrun simctl list devices 2>/dev/null | grep -q "$sim_name"; then
            echo -e "     üì± $sim_name"
        fi
        echo ""
    done

    read -p "Remove all merged worktrees? (y/N): " -n 1 -r
    echo

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        for i in "${!worktrees_to_prune[@]}"; do
            local wt="${worktrees_to_prune[$i]}"
            local br="${branches_to_prune[$i]}"
            local task="${tasks_to_prune[$i]}"

            echo -e "\n${BLUE}Cleaning up: $task${NC}"

            # Remove agent-deck session first
            echo -e "  Removing agent-deck session..."
            remove_agent_deck_session "$task" "$wt"

            # Remove worktree
            echo -e "  Removing worktree..."
            git worktree remove "$wt" --force 2>/dev/null || {
                echo -e "  ${YELLOW}‚ö†Ô∏è  Could not remove worktree, trying harder...${NC}"
                rm -rf "$wt"
                git worktree prune
            }

            # Delete branch
            echo -e "  Deleting branch..."
            if ! gt branch delete "$br" --force 2>/dev/null; then
                git branch -D "$br" 2>/dev/null || true
            fi

            # Delete simulator
            delete_task_simulator "$task"

            echo -e "  ${GREEN}‚úÖ Done${NC}"
        done

        echo -e "\n${GREEN}‚úÖ Pruned ${#worktrees_to_prune[@]} merged worktree(s)${NC}"
    else
        echo -e "${BLUE}Cancelled.${NC}"
    fi
}

cmd_cleanup() {
    local TASK_NAME="$1"

    if [ -z "$TASK_NAME" ]; then
        echo -e "${RED}Usage: convos-task cleanup <task-name>${NC}"
        exit 1
    fi

    WORKTREE_DIR="$BASE_DIR/$REPO_NAME-$TASK_NAME"

    if [ ! -d "$WORKTREE_DIR" ]; then
        echo -e "${RED}Error: Worktree not found at $WORKTREE_DIR${NC}"
        exit 1
    fi

    cd "$WORKTREE_DIR"
    BRANCH_NAME=$(git branch --show-current)

    SIM_NAME=$(get_simulator_name "$TASK_NAME")

    echo -e "${YELLOW}‚ö†Ô∏è  About to remove worktree, Graphite branch, simulator, and agent-deck session:${NC}"
    echo -e "   üìÅ Worktree: $WORKTREE_DIR"
    echo -e "   üåø Branch: $BRANCH_NAME"
    echo -e "   üì± Simulator: $SIM_NAME"
    echo -e "   üéõÔ∏è  Agent-deck session: $TASK_NAME"
    echo ""
    read -p "Are you sure? (y/N): " -n 1 -r
    echo

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        cd "$MAIN_REPO"

        # Remove agent-deck session first (before worktree is deleted)
        remove_agent_deck_session "$TASK_NAME" "$WORKTREE_DIR"

        # Remove worktree
        echo -e "${BLUE}Removing worktree...${NC}"
        git worktree remove "$WORKTREE_DIR" --force

        # Delete Graphite branch
        echo -e "${BLUE}Deleting Graphite branch...${NC}"
        if ! gt delete "$BRANCH_NAME" --force 2>&1; then
            echo -e "${YELLOW}‚ö†Ô∏è  Graphite delete failed, using git directly${NC}"
            git branch -D "$BRANCH_NAME"
        fi

        # Delete task simulator
        delete_task_simulator "$TASK_NAME"

        echo -e "${GREEN}‚úÖ Cleaned up task: $TASK_NAME${NC}"
    else
        echo -e "${BLUE}Cancelled.${NC}"
    fi
}

cmd_sessions() {
    local TASK_NAME="$1"
    local SEARCH_QUERY="$2"

    # Ensure aichat is available
    if ! command -v aichat &>/dev/null; then
        # Try with uv tool path
        export PATH="$HOME/.local/bin:$PATH"
        if ! command -v aichat &>/dev/null; then
            echo -e "${RED}Error: aichat not found. Install with: uv tool install claude-code-tools${NC}"
            exit 1
        fi
    fi

    # Determine which worktree to search
    local SEARCH_PATH=""
    if [ -n "$TASK_NAME" ]; then
        SEARCH_PATH="$BASE_DIR/$REPO_NAME-$TASK_NAME"
        if [ ! -d "$SEARCH_PATH" ]; then
            echo -e "${RED}Error: Worktree not found at $SEARCH_PATH${NC}"
            exit 1
        fi
    elif [[ "$(pwd)" == *"$REPO_NAME"* ]]; then
        SEARCH_PATH="$(pwd)"
    else
        echo -e "${RED}Usage: convos-task sessions [task-name] [search-query]${NC}"
        echo "Or run from within a worktree directory"
        exit 1
    fi

    echo -e "${BLUE}Sessions for: $SEARCH_PATH${NC}\n"

    if [ -n "$SEARCH_QUERY" ]; then
        # Search within task sessions
        aichat search "$SEARCH_QUERY" 2>/dev/null | grep -i "$(basename "$SEARCH_PATH")" || {
            echo "No sessions found matching '$SEARCH_QUERY' in this task"
        }
    else
        # List all sessions for this task using index-stats filtering
        aichat index-stats 2>/dev/null | grep -A1 "Top 5 cwds:" | grep "$(basename "$SEARCH_PATH")" || {
            echo "No sessions found for this task"
            echo ""
            echo -e "${YELLOW}Tip: Build the search index first: aichat build-index${NC}"
        }
    fi
}

cmd_context() {
    local TASK_NAME="$1"

    # Ensure aichat is available
    if ! command -v aichat &>/dev/null; then
        export PATH="$HOME/.local/bin:$PATH"
        if ! command -v aichat &>/dev/null; then
            echo -e "${RED}Error: aichat not found. Install with: uv tool install claude-code-tools${NC}"
            exit 1
        fi
    fi

    # Determine which worktree
    local WORKTREE_PATH=""
    if [ -n "$TASK_NAME" ]; then
        WORKTREE_PATH="$BASE_DIR/$REPO_NAME-$TASK_NAME"
        if [ ! -d "$WORKTREE_PATH" ]; then
            echo -e "${RED}Error: Worktree not found at $WORKTREE_PATH${NC}"
            exit 1
        fi
    elif [[ "$(pwd)" == *"$REPO_NAME"* ]]; then
        WORKTREE_PATH="$(pwd)"
    else
        echo -e "${RED}Usage: convos-task context [task-name]${NC}"
        exit 1
    fi

    local WORKTREE_NAME
    WORKTREE_NAME=$(basename "$WORKTREE_PATH")

    echo -e "${BLUE}Finding latest session for: $WORKTREE_NAME${NC}\n"

    # Get the project hash from Claude's config
    local CLAUDE_HOME="${CLAUDE_CONFIG_DIR:-$HOME/.claude}"
    local PROJECT_DIR=""

    # Find the project directory that matches this worktree
    for dir in "$CLAUDE_HOME/projects"/*; do
        if [ -d "$dir" ]; then
            # Check if any session has this cwd
            if grep -l "\"cwd\":.*$WORKTREE_NAME" "$dir"/*.jsonl 2>/dev/null | head -1 >/dev/null; then
                PROJECT_DIR="$dir"
                break
            fi
        fi
    done

    if [ -z "$PROJECT_DIR" ]; then
        echo -e "${YELLOW}No sessions found for this worktree${NC}"
        echo -e "${YELLOW}Start a Claude Code session in the worktree first${NC}"
        exit 1
    fi

    # Find the most recent session file for this worktree
    local LATEST_SESSION=""
    local LATEST_TIME=0

    for session in "$PROJECT_DIR"/*.jsonl; do
        if grep -q "\"cwd\":.*$WORKTREE_NAME" "$session" 2>/dev/null; then
            local mtime
            mtime=$(stat -f %m "$session" 2>/dev/null || stat -c %Y "$session" 2>/dev/null)
            if [ "$mtime" -gt "$LATEST_TIME" ]; then
                LATEST_TIME=$mtime
                LATEST_SESSION="$session"
            fi
        fi
    done

    if [ -z "$LATEST_SESSION" ]; then
        echo -e "${YELLOW}No sessions found for this worktree${NC}"
        exit 1
    fi

    local SESSION_ID
    SESSION_ID=$(basename "$LATEST_SESSION" .jsonl)

    echo -e "${GREEN}Latest session: $SESSION_ID${NC}"
    echo -e "${BLUE}Modified: $(date -r "$LATEST_TIME" '+%Y-%m-%d %H:%M:%S')${NC}\n"

    # Show session info
    echo -e "${BLUE}Session details:${NC}"
    aichat info "$SESSION_ID" 2>/dev/null || echo "Could not get session info"

    echo ""
    echo -e "${GREEN}To resume this session:${NC}"
    echo "  aichat resume $SESSION_ID"
    echo ""
    echo -e "${GREEN}To search within this session:${NC}"
    echo "  aichat search 'your query' | grep $WORKTREE_NAME"
}

cmd_help() {
    cat << EOF
${BLUE}Convos iOS Task Management${NC}

Manage parallel tasks using git worktrees + Graphite + agent-deck

${GREEN}Commands:${NC}                   ${YELLOW}Shortcuts:${NC}
  new <task-name> [parent]  Create new worktree and Graphite branch    ${YELLOW}n${NC}
  list                      List all active worktrees with status      ${YELLOW}l, ls${NC}
  switch <task-name>        Attach to existing session in agent-deck   ${YELLOW}sw, o${NC}
  submit [task-name]        Submit PR via Graphite (gt submit)         ${YELLOW}sub, pr${NC}
  sync [task-name]          Sync with Graphite stack (gt sync)         ${YELLOW}sy${NC}
  cleanup <task-name>       Remove worktree, branch, and session       ${YELLOW}c, rm${NC}
  prune                     Remove all worktrees with merged branches  ${YELLOW}p${NC}
  sessions [task] [query]   List/search sessions for a task            ${YELLOW}ss${NC}
  context [task-name]       Show latest session and recovery info      ${YELLOW}ctx${NC}
  help                      Show this help                             ${YELLOW}h${NC}

${GREEN}Examples:${NC}
  convos-task new push-notifications
  convos-task new bug-fix dev
  convos-task list
  convos-task submit push-notifications
  convos-task cleanup push-notifications
  convos-task prune
  convos-task sessions push-notifications
  convos-task sessions push-notifications "error handling"
  convos-task context push-notifications

${GREEN}Workflow:${NC}
  1. ${BLUE}convos-task new my-feature${NC}     # Creates worktree + agent-deck session
  2. Work on feature in Claude Code...
  3. ${BLUE}convos-task submit my-feature${NC}   # Submit PR via Graphite
  4. ${BLUE}convos-task cleanup my-feature${NC}  # Remove when done

${GREEN}Agent-Deck Integration:${NC}
  - Sessions are managed via agent-deck (https://github.com/asheshgoplani/agent-deck)
  - ${BLUE}convos-task list${NC} shows session status: üü¢ running, üü° waiting, ‚ö™ idle
  - All sessions are grouped under "convos" in agent-deck
  - Use agent-deck TUI for advanced session management
  - Falls back to iTerm/Terminal if agent-deck is not installed

${GREEN}Session History:${NC}
  - ${BLUE}convos-task sessions${NC}            # Show sessions for current task
  - ${BLUE}convos-task context${NC}             # Get recovery info for last session
  - Sessions are searchable across all worktrees via 'aichat search'

${YELLOW}Notes:${NC}
  - Each worktree is a separate Claude Code session
  - Graphite branches are automatically stacked
  - Each task gets a dedicated iOS simulator (convos-<task-name>)
  - Base simulator is auto-detected (set CONVOS_BASE_SIMULATOR to override)
  - Use 'gt stack' in worktree to see stack structure

${YELLOW}Requirements:${NC}
  - agent-deck: curl -fsSL https://raw.githubusercontent.com/asheshgoplani/agent-deck/main/install.sh | bash
  - tmux (agent-deck dependency)
EOF
}

# Main command dispatcher
case "$1" in
    new|n)
        cmd_new "$2" "$3"
        ;;
    list|ls|l)
        cmd_list
        ;;
    switch|open|sw|o)
        cmd_switch "$2"
        ;;
    submit|pr|sub)
        cmd_submit "$2"
        ;;
    sync|sy)
        cmd_sync "$2"
        ;;
    cleanup|done|rm|c)
        cmd_cleanup "$2"
        ;;
    prune|p)
        cmd_prune
        ;;
    sessions|ss)
        cmd_sessions "$2" "$3"
        ;;
    context|ctx)
        cmd_context "$2"
        ;;
    help|--help|-h|"")
        cmd_help
        ;;
    *)
        echo -e "${RED}Unknown command: $1${NC}"
        echo "Run 'convos-task help' for usage"
        exit 1
        ;;
esac
