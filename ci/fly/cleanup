#!/bin/bash
set -euo pipefail

# Clean up stale ephemeral XMTP backend apps from Fly.io
#
# These apps are created by CI test workflows and should be destroyed after use.
# Each CI workflow has its own cleanup step, but this script catches any leaked apps.
#
# - Apps with no machines are always deleted (definitely stale)
# - Apps with machines are deleted if the oldest machine exceeds --max-age
#
# Usage: ./cleanup [--dry-run] [--max-age HOURS]

ORG="xmtp-labs"
APP_PREFIX="convos-ios-test-"
MAX_AGE_HOURS=2
DRY_RUN=false

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --max-age)
            MAX_AGE_HOURS="$2"
            shift 2
            ;;
        *)
            echo "Unknown option: $1"
            echo "Usage: $0 [--dry-run] [--max-age HOURS]"
            exit 1
            ;;
    esac
done

if [[ -z "${FLY_API_TOKEN:-}" ]]; then
    echo "Error: FLY_API_TOKEN environment variable is required"
    exit 1
fi

echo "==> Looking for stale test apps (prefix: $APP_PREFIX, max age: $MAX_AGE_HOURS hours)"

NOW=$(date +%s)
MAX_AGE_SECONDS=$((MAX_AGE_HOURS * 3600))

# List all apps in the org that match our prefix
# flyctl apps list --json returns objects with "Name" (capitalized)
APPS=$(flyctl apps list --org "$ORG" --json 2>/dev/null | jq -r '.[].Name // empty' | grep "^$APP_PREFIX" || true)

if [[ -z "$APPS" ]]; then
    echo "No test apps found"
    exit 0
fi

APP_COUNT=$(echo "$APPS" | wc -l | tr -d ' ')
echo "Found $APP_COUNT test app(s)"

DELETED_COUNT=0
SKIPPED_COUNT=0

delete_app() {
    local app="$1"
    local reason="$2"
    if [[ "$DRY_RUN" == "true" ]]; then
        echo "[DRY RUN] Would delete: $app ($reason)"
    else
        echo "Deleting: $app ($reason)"
        if flyctl apps destroy "$app" --yes 2>/dev/null; then
            DELETED_COUNT=$((DELETED_COUNT + 1))
        else
            echo "  Warning: Failed to delete $app"
        fi
    fi
}

while IFS= read -r app; do
    if [[ -z "$app" ]]; then
        continue
    fi

    MACHINES_JSON=$(flyctl machines list --app "$app" --json 2>/dev/null || echo "[]")
    MACHINE_COUNT=$(echo "$MACHINES_JSON" | jq 'length' 2>/dev/null || echo "0")

    if [[ "$MACHINE_COUNT" -eq 0 ]]; then
        delete_app "$app" "no machines"
        continue
    fi

    # Get the oldest machine's created_at timestamp
    CREATED_AT=$(echo "$MACHINES_JSON" | jq -r '[.[].created_at] | sort | first // empty' 2>/dev/null)

    if [[ -z "$CREATED_AT" ]]; then
        echo "Keeping: $app (could not determine machine age)"
        SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
        continue
    fi

    # Parse ISO 8601 UTC timestamp to epoch
    # Timestamps from flyctl are UTC, so force TZ=UTC for BSD date
    if date --version 2>/dev/null | grep -q GNU; then
        CREATED_EPOCH=$(date -d "$CREATED_AT" +%s 2>/dev/null || echo "0")
    else
        CREATED_EPOCH=$(TZ=UTC date -j -f "%Y-%m-%dT%H:%M:%S" "${CREATED_AT%%.*}" +%s 2>/dev/null || \
                       TZ=UTC date -j -f "%Y-%m-%dT%H:%M:%SZ" "$CREATED_AT" +%s 2>/dev/null || echo "0")
    fi

    if [[ "$CREATED_EPOCH" == "0" ]]; then
        echo "Keeping: $app (could not parse machine timestamp: $CREATED_AT)"
        SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
        continue
    fi

    AGE_SECONDS=$((NOW - CREATED_EPOCH))
    AGE_HOURS=$((AGE_SECONDS / 3600))
    AGE_MINUTES=$(((AGE_SECONDS % 3600) / 60))

    if [[ $AGE_SECONDS -gt $MAX_AGE_SECONDS ]]; then
        delete_app "$app" "${AGE_HOURS}h ${AGE_MINUTES}m old, $MACHINE_COUNT machine(s)"
    else
        echo "Keeping: $app (${AGE_HOURS}h ${AGE_MINUTES}m old, $MACHINE_COUNT machine(s))"
        SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
    fi
done <<< "$APPS"

echo ""
echo "=========================================="
echo "Cleanup complete"
echo "=========================================="
echo "Deleted: $DELETED_COUNT"
echo "Skipped: $SKIPPED_COUNT"

if [[ "$DRY_RUN" == "true" ]]; then
    echo ""
    echo "(This was a dry run - no apps were actually deleted)"
fi
